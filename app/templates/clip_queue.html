{% extends 'base.html' %}

{% block styles %}
<style>
  
  
  /* Player container with aspect ratio */
  .player-container {
    position: relative;
    padding-bottom: 56.25%; /* 16:9 aspect ratio */
    height: 0;
    overflow: hidden;
  }
  .player-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: 0;
  }
  
  /* Custom toggle switch */
  .switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
  }
  
  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  
  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 24px;
  }
  
  .slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
  }
  
  input:checked + .slider {
    background-color: #2196F3;
  }
  
  input:checked + .slider:before {
    transform: translateX(26px);
  }
  
  .motd {
    font-size: x-small;
    font-weight: bold;
    margin-bottom: 1rem;
    opacity: 0.2;
  }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <div class="row">
      <!-- Video Player Column -->
      <div class="col-lg-8 mb-4">
        <div class="card">
          <div class="card-body p-0">
            <div id="player-area">
              <div class="player-container" id="player-container" style="display: none;" hx-swap-oob="true">
                <!-- Player will be loaded here via HTMX -->
              </div>
              <div id="initial-message" class="d-flex justify-content-center align-items-center h-100" style="min-height: 300px;">
                <div class="text-center p-4">
                  <p class="lead">Select a clip from the "Up Next" list to start watching</p>
                  <p id="motd" class="motd">{{ motd }}</p>
                </div>
              </div>
            </div>
          </div>
          <div class="card-footer bg-transparent d-flex justify-content-between">
            <div id="clip-details" hx-swap="innerHTML">
              <!-- Placeholder for when no clip is selected -->
              <p class="text-muted mb-0">Select a clip to view details</p>
            </div>
            <button class="btn btn-success" id="mark-watched-btn" data-bs-toggle="tooltip" hx-on:click="markWatchedAndNext()" style="display: none;">
              Next
            </button>
          </div>
        </div>
      </div>
      
      <!-- Queue List Column -->
      <div class="col-lg-4">
        <div class="card">
          <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Up Next</h5>
          </div>
          <div class="card-body p-0">
            <div id="queue-items" class="overflow-auto custom-scrollbar" style="max-height: calc(90vh - 200px);" hx-get="/clip_queue/items" hx-trigger="load, queue_update from:body" hx-swap="innerHTML">
              <!-- Queue items will be loaded here via HTMX -->
            </div>
          </div>
        </div>
      </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<!-- HTMX, HTMX-WS Extension, and Socket.IO -->
<script>
  htmx.config.wsReconnectDelay = function (retryCount) {
      const base   = 1000;          // 5 000 ms = 5 s
      const delay  = base * Math.pow(2, retryCount); // exponential
      const capped = Math.min(delay, 60000);         // never more than 1 min
      return capped;
  };
  const sock  = io();                       // default connects to same host:port

  // tell the server which room we care about
  sock.on("connect", () => sock.emit("join_queue"));

  // when the server announces an update, trigger htmx to re-fetch
  sock.on("queue_update", payload => {
    console.log("Queue updated");
      htmx.trigger(document.body, "queue_update");
    });
</script>
<script>
  // Load YouTube IFrame API
  if (!window.YT) {
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  }
  
  var player = null;
  var currentItem = null;
  var playerType = null; // 'youtube' or 'twitch'
  var autoplayEnabled = false;
  
  // Initialize autoplay setting from localStorage
  var autoplayEnabled = localStorage.getItem('autoplayEnabled') === 'true';
  
  // Set up autoplay toggle when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    const autoplayToggle = document.getElementById('autoplay-toggle');
    if (autoplayToggle) {
      autoplayToggle.checked = autoplayEnabled;
      
      // Toggle autoplay setting
      autoplayToggle.addEventListener('change', function() {
        autoplayEnabled = this.checked;
        localStorage.setItem('autoplayEnabled', autoplayEnabled);
      });
    }
  });
  
  // Player setup and initialization is now handled through htmx events
  
  // Function to initialize player after htmx loads it
  function initPlayer() {
    // Clear any existing player
    player = null;
    
    const youtubePlayer = document.getElementById('youtube-player');
    const twitchPlayer = document.getElementById('twitch-player');
    
    if (youtubePlayer) {
      playerType = 'youtube';
      const videoUrl = document.querySelector('.queue-item.active')?.getAttribute('data-url');
      if (videoUrl) {
        createYouTubePlayer(videoUrl);
      }
    } else if (twitchPlayer) {
      playerType = 'twitch';
      // Twitch embedding is automatically handled by their script
    }
  }
  
  function onYouTubeIframeAPIReady() {
    // YouTube API is ready, but don't auto-play anything
    // Let the user select a clip to start playing
    console.log('YouTube API Ready');
    
    // If there's already an active item with a YouTube player waiting to be initialized
    const activeItem = document.querySelector('.queue-item.active');
    const youtubePlayer = document.getElementById('youtube-player');
    
    if (activeItem && youtubePlayer) {
      const videoUrl = activeItem.getAttribute('data-url');
      if (videoUrl && (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be'))) {
        createYouTubePlayer(videoUrl);
      }
    }
  }
  
  // Keep these utility functions for detecting video types
  function isYouTubeUrl(url) {
    return url.includes('youtube.com') || url.includes('youtu.be');
  }
  
  function isTwitchClipUrl(url) {
    return url.includes('clips.twitch.tv/') || url.includes('twitch.tv/videos/') || (url.includes('twitch.tv/') && url.includes('/clip/'));
  }
  
  // Simplified YouTube player creation
  function createYouTubePlayer(url) {
    // Extract video ID and timestamp from URL
    var videoId = '';
    var startTime = 0;
    
    if (url.includes('youtube.com/watch')) {
      // Format: https://www.youtube.com/watch?v=VIDEO_ID&t=1m30s
      var urlParams = new URLSearchParams(url.split('?')[1]);
      videoId = urlParams.get('v');
      
      // Parse timestamp if present
      var timeParam = urlParams.get('t');
      if (timeParam) {
        // Convert timestamp to seconds
        if (timeParam.includes('m')) {
          var parts = timeParam.split('m');
          var minutes = parseInt(parts[0]);
          var seconds = parseInt(parts[1]);
          startTime = minutes * 60 + seconds;
        } else {
          startTime = parseInt(timeParam);
        }
      }
    } else if (url.includes('youtu.be/')) {
      // Format: https://youtu.be/VIDEO_ID?t=1m30s or https://youtu.be/VIDEO_ID?t=90s
      const urlParts = url.split('?');
      videoId = urlParts[0].split('youtu.be/')[1];
      
      // Parse timestamp if present
      if (urlParts.length > 1) {
        const params = new URLSearchParams('?' + urlParts[1]);
        const timeParam = params.get('t');
        
        if (timeParam) {
          // Handle formats: 1m30s, 1m, 90s, or just seconds
          if (timeParam.includes('m') || timeParam.includes('s')) {
            // Handle format like 1m30s or 1m or 30s
            let seconds = 0;
            const minutesMatch = timeParam.match(/(\d+)m/);
            const secondsMatch = timeParam.match(/(\d+)s/);
            
            if (minutesMatch) seconds += parseInt(minutesMatch[1]) * 60;
            if (secondsMatch) seconds += parseInt(secondsMatch[1]);
            
            startTime = seconds;
          } else {
            startTime = parseInt(timeParam);
          }
        }
      }
    }
    else if (url.includes('youtube.com/shorts')) {
      videoId = url.split('youtube.com/shorts/')[1].split('?')[0];   
    }
    
    // Create YouTube player
    player = new YT.Player('youtube-player', {
      height: '100%',
      width: '100%',
      videoId: videoId,
      playerVars: {
        start: startTime,
        autoplay: 1  // Always autoplay when clicked
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
      }
    });
  }
  
  function createTwitchClipPlayer(url) {
    // Extract clip ID or video ID from URL
    var clipId = '';
    var videoId = '';
    var timestamp = '';
    var embedUrl = '';
    var hostname = window.location.hostname || 'localhost';
    
    if (url.includes('clips.twitch.tv/')) {
      // For clips format: https://clips.twitch.tv/ClipName
      clipId = url.split('clips.twitch.tv/')[1].split('?')[0];
      embedUrl = `https://clips.twitch.tv/embed?clip=${clipId}&parent=${hostname}`;
    } else if (url.includes('twitch.tv/') && url.includes('/clip/')) {
      // For new clip format: https://www.twitch.tv/broadcaster/clip/ClipName
      const parts = url.split('/');
      const clipIndex = parts.indexOf('clip');
      if (clipIndex !== -1 && clipIndex + 1 < parts.length) {
        clipId = parts[clipIndex + 1].split('?')[0];
        embedUrl = `https://clips.twitch.tv/embed?clip=${clipId}&parent=${hostname}&preload=auto&muted=false`;
      }
    } else if (url.includes('twitch.tv/videos/')) {
      // For videos format: https://www.twitch.tv/videos/123456789?t=1h2m3s
      videoId = url.split('twitch.tv/videos/')[1].split('?')[0];
      
      // Extract timestamp if present
      if (url.includes('?t=')) {
        timestamp = url.split('?t=')[1];
      }
      
      embedUrl = `https://player.twitch.tv/?video=${videoId}&parent=${hostname}`;
      if (timestamp) {
        embedUrl += `&time=${timestamp}`;
      }
    }
    
    // Create iframe for Twitch
    document.getElementById('player-container').innerHTML = 
      `<iframe src="${embedUrl}" allowfullscreen height="100%" width="100%"></iframe>`;
    
    // Reset YouTube player if it exists
    if (player && playerType === 'youtube') {
      player = null;
    }
  }
  
  function onPlayerReady(event) {
    // Player is ready to receive commands
    console.log('YouTube player is ready');
  }
  
  function onPlayerStateChange(event) {
    // Auto-mark as watched when video ends
    if (event.data === YT.PlayerState.ENDED) {
      console.log('Video ended, auto-marking as watched');
      
      // Simply trigger the mark-watched-btn click which handles everything
      const markWatchedBtn = document.getElementById('mark-watched-btn');
      if (markWatchedBtn) {
        markWatchedBtn.click();
      }
    }
  }
  
  function findNextUnwatched(excludeCurrentItem = false) {
    var items = document.querySelectorAll('.queue-item');
    var activeItem = document.querySelector('.queue-item.active');
    var foundCurrent = false;
    
    // First try to find an unwatched and non-skipped item after the current one
    for (var i = 0; i < items.length; i++) {
      // Skip the current active item if excludeCurrentItem is true
      if (excludeCurrentItem && items[i] === activeItem) {
        foundCurrent = true;
        continue;
      }
      
      if (foundCurrent && 
          items[i].getAttribute('data-watched') === 'false' && 
          items[i].getAttribute('data-skipped') === 'false') {
        return items[i];
      }
      
      if (items[i] === activeItem) {
        foundCurrent = true;
      }
    }
    
    // If no unwatched and non-skipped items after current, look from the beginning
    for (var i = 0; i < items.length; i++) {
      // Skip the current active item if excludeCurrentItem is true
      if (excludeCurrentItem && items[i] === activeItem) {
        continue;
      }
      
      if (items[i].getAttribute('data-watched') === 'false' && 
          items[i].getAttribute('data-skipped') === 'false') {
        return items[i];
      }
    }
    
    // If all items are either watched or skipped, check if there are any unwatched but skipped items
    // This is a fallback if all non-skipped items are watched
    for (var i = 0; i < items.length; i++) {
      // Skip the current active item if excludeCurrentItem is true
      if (excludeCurrentItem && items[i] === activeItem) {
        continue;
      }
      
      if (items[i].getAttribute('data-watched') === 'false') {
        return items[i];
      }
    }
    
    return null; // No unwatched items at all
  }
  
  // Set up htmx event handlers
  htmx.on('htmx:afterSwap', function(e) {
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.map(function (tooltipTriggerEl) {
      return new bootstrap.Tooltip(tooltipTriggerEl);
    });
    
    // Restore active state if queue items were updated
    if (e.detail.target.id === 'queue-items') {
      const activeItemId = localStorage.getItem('activeQueueItemId');
      if (activeItemId) {
        // Remove active class from all items
        document.querySelectorAll('.queue-item').forEach(item => {
          item.classList.remove('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
        });
        // Add active class to the previously active item
        const activeItem = document.querySelector(`.queue-item[data-id="${activeItemId}"]`);
        if (activeItem) {
          activeItem.classList.add('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
        }
      }
    }
    
    // Initialize player if needed after swapping
    if (e.detail.target.id === 'player-container') {
      initPlayer();
    }
  });

  // Function to mark current clip as watched and play next clip
  function markWatchedAndNext() {
    const activeItem = document.querySelector('.queue-item.active');
    if (activeItem) {
      const itemId = activeItem.getAttribute('data-id');
      console.log('Marking as watched and playing next:', itemId);
      
      // Check if this is the last unwatched clip by excluding the current item from search
      const nextUnwatchedItem = findNextUnwatched(true); // true = exclude current item
      let isLastClip = !nextUnwatchedItem;
      
      // Function to show completion message when all clips are watched
      function showCompletionMessage() {
        document.getElementById('player-container').style.display = 'none';
        document.getElementById('initial-message').classList.remove('d-none');
        
        // Update the initial message to show completion
        document.getElementById('initial-message').innerHTML = `
          <div class="text-center p-4">
            <i class="bi bi-check-circle-fill text-success mb-3" style="font-size: 3rem;"></i>
            <h4>All clips watched!</h4>
            <p>You've watched all the clips in the queue.</p>
          </div>`;
        
        // Clear clip details
        document.getElementById('clip-details').innerHTML = `
          <h5 class="mb-0">All clips watched</h5>
          <p class="mb-0">No more clips in queue</p>
        `;
        
        // Clear active state
        document.querySelectorAll('.queue-item').forEach(item => {
          item.classList.remove('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
        });
        localStorage.removeItem('activeQueueItemId');
        
        // Hide the Next button
        document.getElementById('mark-watched-btn').style.display = 'none';
      }
      
      // Only mark as watched if it's not already watched
      if (activeItem.getAttribute('data-watched') === 'false' && isLastClip) {
        // Use fetch API instead of htmx to avoid full queue refresh
        fetch(`/clip_queue/mark_watched/${itemId}`, {
          method: 'POST'
        }).then(response => {
          if (response.ok) {
            htmx.trigger(document.body, 'queue_update');
            showCompletionMessage();
          }
        });
      } else if (!isLastClip) {
        // If already watched and not the last clip, just find and play next unwatched
        playNextUnwatched();
      } else {
        // If already watched and is the last clip, show completion message
        showCompletionMessage();
      }
    }
  }
  
  // Function to find and play the next unwatched clip
  function playNextUnwatched() {
    const nextItem = findNextUnwatched();
    if (nextItem) {
      // Just trigger a click on the next unwatched item
      // The htmx click handler will take care of loading the player and updating UI
      htmx.trigger(nextItem, 'click');
    } else {
      // If no more unwatched items, hide the player and show the initial message
      document.getElementById('player-container').style.display = 'none';
      document.getElementById('initial-message').classList.remove('d-none');
      
      // Update the initial message to show completion
      document.getElementById('initial-message').innerHTML = `
        <div class="text-center p-4">
          <i class="bi bi-check-circle-fill text-success mb-3" style="font-size: 3rem;"></i>
          <h4>All clips watched!</h4>
          <p>You've watched all the clips in the queue.</p>
        </div>`;
      
      // Clear clip details when all clips are watched
      document.getElementById('clip-details').innerHTML = `
        <h5 class="mb-0">All clips watched</h5>
        <p class="mb-0">No more clips in queue</p>
      `;
      
      // Clear active state
      document.querySelectorAll('.queue-item').forEach(item => {
        item.classList.remove('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
      });
      localStorage.removeItem('activeQueueItemId');
      
      // Hide the Next button
      document.getElementById('mark-watched-btn').style.display = 'none';
    }
  }
  
  // Initialize tooltips
  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
  tooltipTriggerList.map(function (tooltipTriggerEl) {
    return new bootstrap.Tooltip(tooltipTriggerEl);
  });
</script>
{% endblock %}
