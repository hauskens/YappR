{% extends 'base.html' %}

{% block styles %}
<style>
  /* Custom styles that can't be replaced with Bootstrap */
  .skip-btn {
    opacity: 0;
    transition: opacity 0.2s;
  }
  .queue-item:hover .skip-btn {
    opacity: 1;
  }
  .queue-item.skipped {
    opacity: 0.6;
  }
  .queue-item.skipped .queue-actions .skip-btn {
    color: #6c757d;
    border-color: #6c757d;
  }
  
  /* Player container with aspect ratio */
  .player-container {
    position: relative;
    padding-bottom: 56.25%; /* 16:9 aspect ratio */
    height: 0;
    overflow: hidden;
  }
  .player-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: 0;
  }
  
  /* Custom toggle switch */
  .switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
  }
  
  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  
  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 24px;
  }
  
  .slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
  }
  
  input:checked + .slider {
    background-color: #2196F3;
  }
  
  input:checked + .slider:before {
    transform: translateX(26px);
  }
  
  /* Thumbnail container with fixed dimensions */
  .queue-thumbnail {
    width: 130px;
    height: 72px;
    flex-shrink: 0;
    overflow: hidden;
  }
  
  .queue-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  
  /* Queue list with fixed height */
  .queue-list {
    max-height: 500px;
  }
  
  /* Transition for queue items */
  .queue-item {
    transition: all 0.2s ease;
    opacity: 1;
  }
  
  .queue-item:hover {
    background-color: rgba(var(--bs-primary-rgb), 0.05);
  }
  
  .queue-item.active {
    background-color: rgba(var(--bs-primary-rgb), 0.1);
  }
  
  .queue-content {
    overflow: hidden;
  }
  
  .cursor-pointer {
    cursor: pointer;
  }
  
  .skipped {
    opacity: 0.5;
  }
  
  .watched {
    opacity: 0.6;
  }
  
  .motd {
    font-size: x-small;
    font-weight: bold;
    margin-bottom: 1rem;
    opacity: 0.2;
  }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <div class="row">
      <!-- Video Player Column -->
      <div class="col-lg-8 mb-4">
        <div class="card">
          <div class="card-body p-0">
            <div id="player-area">
              <div class="player-container" id="player-container" style="display: none;" hx-swap-oob="true">
                <!-- Player will be loaded here via HTMX -->
              </div>
              <div id="initial-message" class="d-flex justify-content-center align-items-center h-100" style="min-height: 300px;">
                <div class="text-center p-4">
                  <p class="lead">Select a clip from the "Up Next" list to start watching</p>
                  <p id="motd" class="motd">{{ motd }}</p>
                </div>
              </div>
            </div>
          </div>
          <div class="card-footer bg-transparent d-flex justify-content-between">
            <div id="clip-details" hx-swap="innerHTML">
              <!-- Placeholder for when no clip is selected -->
              <p class="text-muted mb-0">Select a clip to view details</p>
            </div>
            <button class="btn btn-success" id="mark-watched-btn" data-bs-toggle="tooltip" title="Mark as watched and play next clip" hx-on:click="markWatchedAndNext()" style="display: none;">
              Next
            </button>
          </div>
        </div>
      </div>
      
      <!-- Queue List Column -->
      <div class="col-lg-4">
        <div class="card">
          <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Up Next</h5>
          </div>
          <div class="card-body p-0">
            <div id="queue-items" hx-get="/clip_queue/items" hx-trigger="load, queue_update from:body" hx-swap="innerHTML">
              <!-- Queue items will be loaded here via HTMX -->
            </div>
          </div>
        </div>
      </div>
    </div>
</div>
{% endblock %}

{% block extra_scripts %}
<!-- HTMX, HTMX-WS Extension, and Socket.IO -->
<script>
  htmx.config.wsReconnectDelay = function (retryCount) {
      const base   = 1000;          // 5 000 ms = 5 s
      const delay  = base * Math.pow(2, retryCount); // exponential
      const capped = Math.min(delay, 60000);         // never more than 1 min
      return capped;
  };
  const sock  = io();                       // default connects to same host:port

  // tell the server which room we care about
  sock.on("connect", () => sock.emit("join_queue"));

  // when the server announces an update, trigger htmx to re-fetch
  sock.on("queue_update", payload => {
    console.log("Queue updated");
      htmx.trigger(document.body, "queue_update");
    });
</script>
<script>
  // Load YouTube IFrame API
  if (!window.YT) {
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  }
  
  var player = null;
  var currentItem = null;
  var playerType = null; // 'youtube' or 'twitch'
  var autoplayEnabled = false;
  
  // Initialize autoplay toggle
  // Check if autoplay is enabled from localStorage
  var autoplayEnabled = localStorage.getItem('autoplayEnabled') === 'true';
  const autoplayToggle = document.getElementById('autoplay-toggle');
  if (autoplayToggle) {
    autoplayToggle.checked = autoplayEnabled;
    
    // Toggle autoplay setting
    autoplayToggle.addEventListener('change', function() {
      autoplayEnabled = this.checked;
      localStorage.setItem('autoplayEnabled', autoplayEnabled);
    });
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    // Set up the mark-watched button
    const markWatchedBtn = document.getElementById('mark-watched-btn');
    if (markWatchedBtn) {
      markWatchedBtn.addEventListener('click', function() {
        const activeItem = document.querySelector('.queue-item.active');
        if (activeItem) {
          const itemId = activeItem.getAttribute('data-id');
          markWatchedBtn.setAttribute('hx-post', `/clip_queue/mark_watched/${itemId}`);
          
          // Find next unwatched item
          const nextItem = findNextUnwatched();
          if (nextItem) {
            // Trigger click on next item after marking current as watched
            setTimeout(() => {
              nextItem.click();
            }, 100);
          }
        }
      });
    }
  });
  
  // Function to initialize player after htmx loads it
  function initPlayer() {
    const youtubePlayer = document.getElementById('youtube-player');
    if (youtubePlayer && youtubePlayer.getAttribute('data-video-url')) {
      createYouTubePlayer(youtubePlayer.getAttribute('data-video-url'));
      playerType = 'youtube';
    }
  }
  
  function onYouTubeIframeAPIReady() {
    // YouTube API is ready, but don't auto-play anything
    // Let the user select a clip to start playing
    console.log('YouTube API Ready');
    
    // If there's already an active item with a YouTube player waiting to be initialized
    const activeItem = document.querySelector('.queue-item.active');
    const youtubePlayer = document.getElementById('youtube-player');
    
    if (activeItem && youtubePlayer) {
      const videoUrl = activeItem.getAttribute('data-url');
      if (videoUrl && (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be'))) {
        createYouTubePlayer(videoUrl);
      }
    }
  }
  
  // Keep these utility functions for detecting video types
  function isYouTubeUrl(url) {
    return url.includes('youtube.com') || url.includes('youtu.be');
  }
  
  function isTwitchClipUrl(url) {
    return url.includes('clips.twitch.tv/') || url.includes('twitch.tv/videos/') || (url.includes('twitch.tv/') && url.includes('/clip/'));
  }
  
  // Simplified YouTube player creation
  function createYouTubePlayer(url) {
    // Extract video ID and timestamp from URL
    var videoId = '';
    var startTime = 0;
    
    if (url.includes('youtube.com/watch')) {
      // Format: https://www.youtube.com/watch?v=VIDEO_ID&t=1m30s
      var urlParams = new URLSearchParams(url.split('?')[1]);
      videoId = urlParams.get('v');
      
      // Parse timestamp if present
      var timeParam = urlParams.get('t');
      if (timeParam) {
        // Convert timestamp to seconds
        if (timeParam.includes('m')) {
          var parts = timeParam.split('m');
          var minutes = parseInt(parts[0]);
          var seconds = parseInt(parts[1]);
          startTime = minutes * 60 + seconds;
        } else {
          startTime = parseInt(timeParam);
        }
      }
    } else if (url.includes('youtu.be/')) {
      // Format: https://youtu.be/VIDEO_ID?t=1m30s or https://youtu.be/VIDEO_ID?t=90s
      const urlParts = url.split('?');
      videoId = urlParts[0].split('youtu.be/')[1];
      
      // Parse timestamp if present
      if (urlParts.length > 1) {
        const params = new URLSearchParams('?' + urlParts[1]);
        const timeParam = params.get('t');
        
        if (timeParam) {
          // Handle formats: 1m30s, 1m, 90s, or just seconds
          if (timeParam.includes('m') || timeParam.includes('s')) {
            // Handle format like 1m30s or 1m or 30s
            let seconds = 0;
            const minutesMatch = timeParam.match(/(\d+)m/);
            const secondsMatch = timeParam.match(/(\d+)s/);
            
            if (minutesMatch) seconds += parseInt(minutesMatch[1]) * 60;
            if (secondsMatch) seconds += parseInt(secondsMatch[1]);
            
            startTime = seconds;
          } else {
            startTime = parseInt(timeParam);
          }
        }
      }
    }
    else if (url.includes('youtube.com/shorts')) {
      videoId = url.split('youtube.com/shorts/')[1].split('?')[0];   
    }
    
    // Create YouTube player
    player = new YT.Player('youtube-player', {
      height: '100%',
      width: '100%',
      videoId: videoId,
      playerVars: {
        start: startTime,
        autoplay: 1  // Always autoplay when clicked
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
      }
    });
  }
  
  function createTwitchClipPlayer(url) {
    // Extract clip ID or video ID from URL
    var clipId = '';
    var videoId = '';
    var timestamp = '';
    var embedUrl = '';
    var hostname = window.location.hostname || 'localhost';
    
    if (url.includes('clips.twitch.tv/')) {
      // For clips format: https://clips.twitch.tv/ClipName
      clipId = url.split('clips.twitch.tv/')[1].split('?')[0];
      embedUrl = `https://clips.twitch.tv/embed?clip=${clipId}&parent=${hostname}`;
    } else if (url.includes('twitch.tv/') && url.includes('/clip/')) {
      // For new clip format: https://www.twitch.tv/broadcaster/clip/ClipName
      const parts = url.split('/');
      const clipIndex = parts.indexOf('clip');
      if (clipIndex !== -1 && clipIndex + 1 < parts.length) {
        clipId = parts[clipIndex + 1].split('?')[0];
        embedUrl = `https://clips.twitch.tv/embed?clip=${clipId}&parent=${hostname}&preload=auto&muted=false`;
      }
    } else if (url.includes('twitch.tv/videos/')) {
      // For videos format: https://www.twitch.tv/videos/123456789?t=1h2m3s
      videoId = url.split('twitch.tv/videos/')[1].split('?')[0];
      
      // Extract timestamp if present
      if (url.includes('?t=')) {
        timestamp = url.split('?t=')[1];
      }
      
      embedUrl = `https://player.twitch.tv/?video=${videoId}&parent=${hostname}`;
      if (timestamp) {
        embedUrl += `&time=${timestamp}`;
      }
    }
    
    // Create iframe for Twitch
    document.getElementById('player-container').innerHTML = 
      `<iframe src="${embedUrl}" allowfullscreen height="100%" width="100%"></iframe>`;
    
    // Reset YouTube player if it exists
    if (player && playerType === 'youtube') {
      player = null;
    }
  }
  
  function onPlayerReady(event) {
    // Player is ready to receive commands
    console.log('YouTube player is ready');
  }
  
  function onPlayerStateChange(event) {
    console.log('Player state changed to:', event.data);
    
    // Auto-mark as watched when video ends
    if (event.data === YT.PlayerState.ENDED) {
      console.log('Video ended, marking as watched');
      
      // Get the active item
      const activeItem = document.querySelector('.queue-item.active');
      if (activeItem) {
        const itemId = activeItem.getAttribute('data-id');
        console.log('Marking item as watched:', itemId);
        
        // Use htmx to mark as watched
        htmx.ajax('POST', `/clip_queue/mark_watched/${itemId}`, { target: '#queue-items', swap: 'innerHTML' });
        
        // Only proceed with autoplay if it's enabled
        if (autoplayEnabled) {
          // Find next unwatched item
          var nextItem = findNextUnwatched();
          if (nextItem) {
            // Trigger click on next item
            setTimeout(() => {
              nextItem.click();
            }, 100);
          } else {
            console.log('No more unwatched items in queue');
          }
        }
      }
    }
  }
  
  function findNextUnwatched() {
    var items = document.querySelectorAll('.queue-item');
    var activeItem = document.querySelector('.queue-item.active');
    var foundCurrent = false;
    
    // First try to find an unwatched and non-skipped item after the current one
    for (var i = 0; i < items.length; i++) {
      if (foundCurrent && 
          items[i].getAttribute('data-watched') === 'false' && 
          items[i].getAttribute('data-skipped') === 'false') {
        return items[i];
      }
      
      if (items[i] === activeItem) {
        foundCurrent = true;
      }
    }
    
    // If no unwatched and non-skipped items after current, look from the beginning
    for (var i = 0; i < items.length; i++) {
      if (items[i].getAttribute('data-watched') === 'false' && 
          items[i].getAttribute('data-skipped') === 'false') {
        return items[i];
      }
    }
    
    // If all items are either watched or skipped, check if there are any unwatched but skipped items
    // This is a fallback if all non-skipped items are watched
    for (var i = 0; i < items.length; i++) {
      if (items[i].getAttribute('data-watched') === 'false') {
        return items[i];
      }
    }
    
    return null; // No unwatched items at all
  }
  
  // Set up event listeners when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    
    // Initialize tooltips after content updates
    htmx.on('htmx:afterSwap', function(e) {
      var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
      tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl);
      });
      
      // Restore active state if queue items were updated
      if (e.detail.target.id === 'queue-items') {
        const activeItemId = localStorage.getItem('activeQueueItemId');
        if (activeItemId) {
          console.log('Restoring active state for item:', activeItemId);
          // Remove active class from all items
          document.querySelectorAll('.queue-item').forEach(item => {
            item.classList.remove('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
          });
          // Add active class to the previously active item
          const activeItem = document.querySelector(`.queue-item[data-id="${activeItemId}"]`);
          if (activeItem) {
            activeItem.classList.add('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
          }
        }
      }
      
      // Check if we swapped in a YouTube player and initialize it
      if (e.detail.target.id === 'player-container' && document.getElementById('youtube-player')) {
        const activeItem = document.querySelector('.queue-item.active');
        if (activeItem) {
          const videoUrl = activeItem.getAttribute('data-url');
          if (videoUrl && (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be'))) {
            // Wait a bit for YouTube API to be ready if needed
            if (typeof YT !== 'undefined' && YT.Player) {
              createYouTubePlayer(videoUrl);
            } else {
              // If YouTube API isn't ready yet, wait for it
              window.onYouTubeIframeAPIReady = function() {
                createYouTubePlayer(videoUrl);
              };
            }
          }
        }
      }
    });
    
    // Function to handle marking previous item as watched when clicking a new one
    function setupQueueItemClickHandlers() {
      console.log('Setting up queue item click handlers');
      
      // Use event delegation on the document level to ensure it works with htmx content swaps
      document.addEventListener('click', function(event) {
        // Find the clicked queue item
        const clickedItem = event.target.closest('.queue-item');
        if (!clickedItem) return; // Not a queue item click
        
        // Store the clicked item ID in localStorage so we can restore active state after htmx updates
        const clickedItemId = clickedItem.getAttribute('data-id');
        localStorage.setItem('activeQueueItemId', clickedItemId);
        console.log('Setting active item ID:', clickedItemId);
        
        // Find the currently active item
        const activeItem = document.querySelector('.queue-item.active');
        if (activeItem && activeItem !== clickedItem && activeItem.getAttribute('data-watched') === 'false') {
          // Mark the active item as watched before switching
          const itemId = activeItem.getAttribute('data-id');
          console.log('Marking previous item as watched:', itemId);
          
          fetch(`/clip_queue/mark_watched/${itemId}`, {
            method: 'POST'
          }).then(response => {
            if (response.ok) {
              // Update UI to show watched state
              activeItem.classList.add('watched');
              activeItem.setAttribute('data-watched', 'true');
              
              const watchedIndicator = activeItem.querySelector('.watched-indicator');
              if (watchedIndicator) {
                watchedIndicator.classList.remove('d-none');
              }
            }
          });
        }
        
        // Update active state immediately
        document.querySelectorAll('.queue-item').forEach(item => {
          item.classList.remove('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
        });
        clickedItem.classList.add('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
      }, true); // Use capture to ensure this runs before htmx processing
    }
    
    // Set up the click handlers
    setupQueueItemClickHandlers();
  });

  // Function to mark current clip as watched and play next clip
  function markWatchedAndNext() {
    const activeItem = document.querySelector('.queue-item.active');
    if (activeItem) {
      const itemId = activeItem.getAttribute('data-id');
      console.log('Marking as watched and playing next:', itemId);
      
      // First check if this is the last unwatched clip
      let isLastClip = true;
      document.querySelectorAll('.queue-item').forEach(item => {
        if (item !== activeItem && item.getAttribute('data-watched') === 'false' && item.getAttribute('data-skipped') !== 'true') {
          isLastClip = false;
        }
      });
      
      // Only mark as watched if it's not already watched
      if (activeItem.getAttribute('data-watched') === 'false') {
        // Use fetch API instead of htmx to avoid full queue refresh
        fetch(`/clip_queue/mark_watched/${itemId}`, {
          method: 'POST'
        }).then(response => {
          if (response.ok) {
            // Update the UI to reflect watched state
            activeItem.classList.add('watched');
            activeItem.setAttribute('data-watched', 'true');
            
            // Update any watched indicators in the UI
            const watchedIndicator = activeItem.querySelector('.watched-indicator');
            if (watchedIndicator) {
              watchedIndicator.classList.remove('d-none');
            }
            
            if (isLastClip) {
              // If this was the last clip, hide player and show completion message
              document.getElementById('player-container').style.display = 'none';
              document.getElementById('initial-message').classList.remove('d-none');
              
              // Update the initial message to show completion
              document.getElementById('initial-message').innerHTML = `
                <div class="text-center p-4">
                  <i class="bi bi-check-circle-fill text-success mb-3" style="font-size: 3rem;"></i>
                  <h4>All clips watched!</h4>
                  <p>You've watched all the clips in the queue.</p>
                </div>`;
              
              // Clear clip details
              document.getElementById('clip-details').innerHTML = `
                <h5 class="mb-0">All clips watched</h5>
                <p class="mb-0">No more clips in queue</p>
              `;
              
              // Clear active state
              document.querySelectorAll('.queue-item').forEach(item => {
                item.classList.remove('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
              });
              localStorage.removeItem('activeQueueItemId');
              
              // Hide the Next button
              document.getElementById('mark-watched-btn').style.display = 'none';
            } else {
              // If there's another unwatched clip, play it
              playNextUnwatched();
            }
          }
        });
      } else if (!isLastClip) {
        // If already watched and not the last clip, just find and play next unwatched
        playNextUnwatched();
      } else {
        // If already watched and is the last clip, show completion message
        document.getElementById('player-container').style.display = 'none';
        document.getElementById('initial-message').classList.remove('d-none');
        
        // Update the initial message to show completion
        document.getElementById('initial-message').innerHTML = `
          <div class="text-center p-4">
            <i class="bi bi-check-circle-fill text-success mb-3" style="font-size: 3rem;"></i>
            <h4>All clips watched!</h4>
            <p>You've watched all the clips in the queue.</p>
          </div>`;
        
        // Clear clip details
        document.getElementById('clip-details').innerHTML = `
          <h5 class="mb-0">All clips watched</h5>
          <p class="mb-0">No more clips in queue</p>
        `;
        
        // Clear active state
        document.querySelectorAll('.queue-item').forEach(item => {
          item.classList.remove('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
        });
        localStorage.removeItem('activeQueueItemId');
        
        // Hide the Next button
        document.getElementById('mark-watched-btn').style.display = 'none';
      }
    }
  }
  
  // Function to find and play the next unwatched clip
  function playNextUnwatched() {
    const nextItem = findNextUnwatched();
    if (nextItem) {
      // Get the item ID for updating clip details
      const nextItemId = nextItem.getAttribute('data-id');
      
      // Update active state
      document.querySelectorAll('.queue-item').forEach(item => {
        item.classList.remove('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
      });
      nextItem.classList.add('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
      
      // Load the player content
      fetch(`/clip_queue/player/${nextItemId}`)
        .then(response => response.text())
        .then(html => {
          document.getElementById('player-container').innerHTML = html;
          document.getElementById('initial-message').classList.add('d-none');
          document.getElementById('player-container').style.display = 'block';
          
          // Initialize the player
          initPlayer();
          
          // Update clip details
          return fetch(`/clip_queue/details/${nextItemId}`);
        })
        .then(response => response.text())
        .then(html => {
          document.getElementById('clip-details').innerHTML = html;
        });
    } else {
      // If no more unwatched items, hide the player and show the initial message
      document.getElementById('player-container').style.display = 'none';
      document.getElementById('initial-message').classList.remove('d-none');
      
      // Update the initial message to show completion
      document.getElementById('initial-message').innerHTML = `
        <div class="text-center p-4">
          <i class="bi bi-check-circle-fill text-success mb-3" style="font-size: 3rem;"></i>
          <h4>All clips watched!</h4>
          <p>You've watched all the clips in the queue.</p>
        </div>`;
      
      // Clear clip details when all clips are watched
      document.getElementById('clip-details').innerHTML = `
        <h5 class="mb-0">All clips watched</h5>
        <p class="mb-0">No more clips in queue</p>
      `;
      
      // Clear active state
      document.querySelectorAll('.queue-item').forEach(item => {
        item.classList.remove('active', 'bg-primary-subtle', 'border-start', 'border-2', 'border-primary-subtle');
      });
      localStorage.removeItem('activeQueueItemId');
      
      // Hide the Next button
      document.getElementById('mark-watched-btn').style.display = 'none';
    }
  }
  
  // Initialize tooltips
  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
  tooltipTriggerList.map(function (tooltipTriggerEl) {
    return new bootstrap.Tooltip(tooltipTriggerEl);
  });
</script>
{% endblock %}
