{% extends 'base.html' %}

{% block styles %}
<style>
  /* Custom styles that can't be replaced with Bootstrap */
  .skip-btn {
    opacity: 0;
    transition: opacity 0.2s;
  }
  .queue-item:hover .skip-btn {
    opacity: 1;
  }
  .queue-item.skipped {
    opacity: 0.6;
  }
  .queue-item.skipped .queue-actions .skip-btn {
    color: #6c757d;
    border-color: #6c757d;
  }
  
  /* Player container with aspect ratio */
  .player-container {
    position: relative;
    padding-bottom: 56.25%; /* 16:9 aspect ratio */
    height: 0;
    overflow: hidden;
  }
  .player-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: 0;
  }
  
  /* Custom toggle switch */
  .switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
  }
  
  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  
  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 24px;
  }
  
  .slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
  }
  
  input:checked + .slider {
    background-color: #2196F3;
  }
  
  input:checked + .slider:before {
    transform: translateX(26px);
  }
  
  /* Thumbnail container with fixed dimensions */
  .queue-thumbnail {
    width: 120px;
    height: 68px;
    background-color: #f8f9fa;
    flex-shrink: 0;
    overflow: hidden;
  }
  
  .queue-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  
  /* Queue list with fixed height */
  .queue-list {
    max-height: 500px;
  }
  
  /* Transition for queue items */
  .queue-item {
    transition: all 0.2s;
  }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
  {% if queue_items %}
    <div class="row">
      <!-- Video Player Column -->
      <div class="col-lg-8 mb-4">
        <div class="card">
          <div class="card-header">
            <h5 class="mb-0" id="current-title">Now Playing</h5>
          </div>
          <div class="card-body p-0">
            <div class="player-container" id="player-container">
              <!-- Player will be inserted here via JavaScript -->
              <div class="d-flex justify-content-center align-items-center h-100 bg-light">
                <p class="text-muted">Select a clip to start playing</p>
              </div>
            </div>
          </div>
          <div class="card-footer bg-transparent d-flex justify-content-end">
            <div class="autoplay-toggle d-flex align-items-center gap-2 mb-3 me-3">
              <label class="switch">
                <input type="checkbox" id="autoplay-toggle">
                <span class="slider"></span>
              </label>
              <span>Autoplay</span>
            </div>
            <button class="btn btn-success" id="mark-watched-btn" data-bs-toggle="tooltip" title="Mark as watched and play next clip">Next</button>
          </div>
        </div>
      </div>
      
      <!-- Queue List Column -->
      <div class="col-lg-4">
        <div class="card">
          <div class="card-header">
            <h5 class="mb-0">Up Next</h5>
          </div>
          <div class="card-body p-0">
            <div class="queue-list overflow-auto">
              {% for item in queue_items %}
                <div class="queue-item position-relative d-flex mb-2 p-2 border border-light-subtle rounded cursor-pointer{% if loop.first %} active bg-primary-subtle border-start border-2 border-primary-subtle{% endif %}{% if item.skipped %} skipped{% endif %}" 
                     data-id="{{ item.id }}" 
                     data-url="{{ item.content.url }}" 
                     data-title="{{ item.content.title }}"
                     data-watched="{{ item.watched|lower }}"
                     data-skipped="{{ item.skipped|lower }}">
                  <div class="queue-item-content d-flex align-items-center flex-grow-1 min-width-0 cursor-pointer" onclick="playContent(this.parentElement)">
                  {% if item.content.thumbnail_url %}
                  <div class="queue-thumbnail me-3 d-flex align-items-center justify-content-center text-muted" style="background-color: transparent;">
                    <img src="{{ item.content.thumbnail_url }}" alt="Thumbnail" class="img-fluid rounded ">
                  </div>
                  {% endif %}
                  <div class="queue-content flex-grow-1 min-width-0">
                    <div class="queue-title fw-bold mb-1 text-truncate">{{ item.content.title|truncate(50) }}</div>
                    <div class="queue-meta fs-6 text-muted">
                      <div class="d-flex flex-wrap align-items-center gap-2">
                        {% if item.content.get_platform() == 'youtube' %}
                          <img src="https://img.shields.io/badge/{{ item.content.channel_name | urlencode }}-FF0000?style=plastic&logo=youtube&logoColor=white&color=6C757D&labelColor=FF0000" alt="YouTube logo badge">
                        {% elif item.content.get_platform() == 'twitch' %}
                          <img src="https://img.shields.io/badge/{{ item.content.channel_name | urlencode }}-9147FF?style=plastic&logo=twitch&logoColor=white&labelColor=9147FF&color=6C757D" alt="Twitch badge">
                        {% endif %}

                        {% if item.content.duration %}
                          {% set minutes = (item.content.duration // 60)|int %}
                          {% set seconds = (item.content.duration % 60)|int %}
                          <span class="badge bg-secondary">{{ "%d:%02d"|format(minutes, seconds) }}</span>
                        {% endif %}
                        {% if item.submissions %}
                          {% set earliest = (item.submissions | sort(attribute='submitted_at'))[0] %}
                          {% set seconds_diff = (now - earliest.submitted_at).total_seconds()|int %}
                          {% set minutes_diff = (seconds_diff / 60)|int %}
                          {% set hours_diff = (seconds_diff / 3600)|int %}
                          {% set days_diff = (hours_diff / 24)|int %}
                          <span class="text-muted">â€¢</span>
                          <span class="text-muted" data-bs-toggle="tooltip" 
                                title="{{ earliest.submitted_at.strftime('%Y-%m-%d %H:%M:%S') }}">
                            Added {% if hours_diff >= 24 %}{{ days_diff }} day{% if days_diff != 1 %}s{% endif %}{% elif hours_diff >= 1 %}{{ hours_diff }} hour{% if hours_diff != 1 %}s{% endif %}{% else %}{{ minutes_diff }} minute{% if minutes_diff != 1 %}s{% endif %}{% endif %} ago
                          </span>
                        {% endif %}
                      </div>
                      <div class="d-flex flex-wrap align-items-center gap-1 mt-1">
                        {% if item.watched %}
                          <span class="badge bg-success">Watched</span>
                        {% endif %}
                        {% for submission in item.submissions %}
                          {% if submission.submission_source_type.name == "Twitch" %}
                            <span class="badge" style="background-color: #9147FF; color: white;" data-bs-toggle="tooltip" title="{{ submission.user_comment or '' }}">
                              {{ submission.user.username }}{{ '*' if submission.user_comment is not none else '' }}
                            </span>
                          {% elif submission.submission_source_type.name == "Discord" %}
                            <span class="badge" style="background-color: #7289da; color: white;" data-bs-toggle="tooltip" title="{{ submission.user_comment or '' }}">
                              {{ submission.user.username }}{{ '*' if submission.user_comment is not none else '' }}
                            </span>
                          {% endif %}
                        {% endfor %}
                      </div>
                    </div>
                  </div>
                  </div><div class="queue-actions ms-auto px-2 d-flex align-items-center">
                    <button class="btn btn-sm btn-outline-secondary skip-btn" 
                            onclick="event.stopPropagation(); skipItem({{ item.id }})"
                            data-bs-toggle="tooltip" 
                            title="Skip this clip">
                      <i class="bi bi-skip-forward"></i>
                    </button>
                  </div>
                </div>
              {% endfor %}
            </div>
          </div>
        </div>
      </div>
    </div>
  {% else %}
    <div class="alert alert-info">
      <p>Your clip queue is empty. When people share YouTube videos or Twitch clips in your chat, they'll appear here.</p>
    </div>
  {% endif %}
</div>
{% endblock %}

{% block extra_scripts %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js" integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==" crossorigin="anonymous"></script>
<script>
  document.addEventListener('DOMContentLoaded', (event) => {
console.log('hello');
var socket = io('http://localhost:5000');

socket.on('connect', function() {

    socket.send('User has connected!');

});

socket.on('message', function(msg) {

    var p = document.createElement('p');

    p.innerText = msg;

    document.body.appendChild(p);

});

});
</script>
<script>
  // YouTube API
  var tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  
  var player = null;
  var currentItem = null;
  var playerType = null; // 'youtube' or 'twitch'
  var autoplayEnabled = true;
  
  // Initialize autoplay toggle
  const autoplayToggle = document.getElementById('autoplay-toggle');
  if (autoplayToggle) {
    autoplayToggle.addEventListener('change', function(e) {
      autoplayEnabled = e.target.checked;
      console.log('Autoplay ' + (autoplayEnabled ? 'enabled' : 'disabled'));
    });
  }
  
  function onYouTubeIframeAPIReady() {
    // YouTube API is ready
    if (document.querySelector('.queue-item')) {
      playContent(document.querySelector('.queue-item'));
    }
  }
  
  function playContent(element) {
    // Update active item styling
    document.querySelectorAll('.queue-item').forEach(item => {
      item.classList.remove('active');
      item.classList.remove('bg-primary-subtle');
      item.classList.remove('border-start');
      item.classList.remove('border-2');
      item.classList.remove('border-primary-subtle');
    });
    
    // Add active class and related Bootstrap classes to the clicked item
    element.classList.add('active');
    element.classList.add('bg-primary-subtle');
    element.classList.add('border-start');
    element.classList.add('border-2');
    element.classList.add('border-primary-subtle');
    
    currentItem = element;
    var contentUrl = element.getAttribute('data-url');
    var contentTitle = element.getAttribute('data-title');
    var contentId = element.getAttribute('data-id');
    
    // Update title
    document.getElementById('current-title').textContent = contentTitle;
    
    // Determine content type and create appropriate player
    if (isYouTubeUrl(contentUrl)) {
      createYouTubePlayer(contentUrl);
      playerType = 'youtube';
    } else if (isTwitchClipUrl(contentUrl)) {
      createTwitchClipPlayer(contentUrl);
      playerType = 'twitch';
    } else {
      // Fallback for unsupported URLs
      document.getElementById('player-container').innerHTML = 
        `<div class="d-flex justify-content-center align-items-center h-100 bg-light">
          <p class="text-muted">Unsupported content type</p>
         </div>`;
      playerType = null;
    }
  }
  
  function isYouTubeUrl(url) {
    return url.includes('youtube.com/watch') || url.includes('youtu.be/');
  }
  
  function isTwitchClipUrl(url) {
    return url.includes('clips.twitch.tv/') || url.includes('twitch.tv/videos/');
  }
  
  function createYouTubePlayer(url) {
    // Extract video ID and timestamp from URL
    var videoId = '';
    var startTime = 0;
    
    if (url.includes('youtube.com/watch')) {
      // Format: https://www.youtube.com/watch?v=VIDEO_ID&t=1m30s
      var urlParams = new URLSearchParams(url.split('?')[1]);
      videoId = urlParams.get('v');
      
      // Parse timestamp if present
      var timeParam = urlParams.get('t');
      if (timeParam) {
        // Convert timestamp to seconds
        if (timeParam.includes('m')) {
          var parts = timeParam.split('m');
          var minutes = parseInt(parts[0]);
          var seconds = parseInt(parts[1]);
          startTime = minutes * 60 + seconds;
        } else {
          startTime = parseInt(timeParam);
        }
      }
    } else if (url.includes('youtu.be/')) {
      // Format: https://youtu.be/VIDEO_ID?t=1m30s or https://youtu.be/VIDEO_ID?t=90s
      const urlParts = url.split('?');
      videoId = urlParts[0].split('youtu.be/')[1];
      
      // Parse timestamp if present
      if (urlParts.length > 1) {
        const params = new URLSearchParams('?' + urlParts[1]);
        const timeParam = params.get('t');
        
        if (timeParam) {
          // Handle formats: 1m30s, 1m, 90s, or just seconds
          if (timeParam.includes('m') || timeParam.includes('s')) {
            // Handle format like 1m30s or 1m or 30s
            let seconds = 0;
            const minutesMatch = timeParam.match(/(\d+)m/);
            const secondsMatch = timeParam.match(/(\d+)s/);
            
            if (minutesMatch) seconds += parseInt(minutesMatch[1]) * 60;
            if (secondsMatch) seconds += parseInt(secondsMatch[1]);
            
            startTime = seconds;
          } else {
            startTime = parseInt(timeParam);
          }
          console.log('Using start time:', startTime, 'seconds');
        }
      }
    }
    
    // Create a div with an ID for the YouTube player
    document.getElementById('player-container').innerHTML = '<div id="youtube-player"></div>';
    
    // Make sure the container has the right dimensions
    document.getElementById('youtube-player').style.width = '100%';
    document.getElementById('youtube-player').style.height = '100%';
    
    // Create YouTube player
    player = new YT.Player('youtube-player', {
      height: '100%',
      width: '100%',
      videoId: videoId,
      playerVars: {
        start: startTime,
        autoplay: 1
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
      }
    });
  }
  
  function createTwitchClipPlayer(url) {
    // Extract clip ID or video ID from URL
    var clipId = '';
    var videoId = '';
    var timestamp = '';
    var embedUrl = '';
    
    if (url.includes('clips.twitch.tv/')) {
      // For clips format: https://clips.twitch.tv/ClipName
      clipId = url.split('clips.twitch.tv/')[1].split('?')[0];
      embedUrl = `https://clips.twitch.tv/embed?clip=${clipId}&parent=${window.location.hostname}`;
    } else if (url.includes('twitch.tv/videos/')) {
      // For videos format: https://www.twitch.tv/videos/123456789?t=1h2m3s
      videoId = url.split('twitch.tv/videos/')[1].split('?')[0];
      
      // Extract timestamp if present
      if (url.includes('?t=')) {
        timestamp = url.split('?t=')[1];
      }
      
      embedUrl = `https://player.twitch.tv/?video=${videoId}&parent=${window.location.hostname}`;
      if (timestamp) {
        embedUrl += `&time=${timestamp}`;
      }
    }
    
    // Create iframe for Twitch
    document.getElementById('player-container').innerHTML = 
      `<iframe src="${embedUrl}" allowfullscreen="true" autoplay="true"></iframe>`;
    
    // Reset YouTube player if it exists
    if (player && playerType === 'youtube') {
      player = null;
    }
  }
  
  function onPlayerReady(event) {
    // Player is ready to receive commands
    console.log('YouTube player is ready');
  }
  
  function onPlayerStateChange(event) {
    console.log('Player state changed to:', event.data);
    
    // Auto-mark as watched when video ends
    if (event.data === YT.PlayerState.ENDED) {
      console.log('Video ended, marking as watched');
      
      // Make sure currentItem is defined
      if (currentItem) {
        const currentItemId = currentItem.getAttribute('data-id');
        console.log('Marking item as watched:', currentItemId);
        
        // Mark the current item as watched
        markAsWatched(currentItemId);
        
        // Only proceed with autoplay if it's enabled
        if (autoplayEnabled) {
          // Find next unwatched item
          var nextItem = findNextUnwatched();
          // Only play next item if it's different from the current item
          if (nextItem && (!currentItem || nextItem.getAttribute('data-id') !== currentItemId)) {
            playContent(nextItem);
          } else {
            console.log('No more unwatched items in queue or reached the last item');
          }
        } else {
          console.log('Autoplay is disabled');
        }
      } else {
        console.error('No current item defined');
      }
    }
  }
  
  function findNextUnwatched() {
    var items = document.querySelectorAll('.queue-item');
    var foundCurrent = false;
    
    for (var i = 0; i < items.length; i++) {
      if (foundCurrent && items[i].getAttribute('data-watched') === 'false') {
        return items[i];
      }
      
      if (items[i] === currentItem) {
        foundCurrent = true;
      }
    }
    
    // If no unwatched items after current, return first unwatched
    for (var i = 0; i < items.length; i++) {
      if (items[i].getAttribute('data-watched') === 'false') {
        return items[i];
      }
    }
    
    return null; // No unwatched items
  }
  
  function markAsWatched(itemId) {
    console.log('Marking item as watched:', itemId);
    
    // Send AJAX request to mark item as watched
    fetch(`/clip_queue/mark_watched/${itemId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
      }
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        console.log('Successfully marked as watched in database');
        
        // Find the specific item by ID and update its UI
        const itemToUpdate = document.querySelector(`.queue-item[data-id="${itemId}"]`);
        if (itemToUpdate) {
          console.log('Updating UI for item:', itemId);
          itemToUpdate.setAttribute('data-watched', 'true');
          
          // Add a watched badge if it doesn't exist
          let watchedBadgeExists = false;
          const badges = itemToUpdate.querySelectorAll('.badge');
          badges.forEach(badge => {
            if (badge.textContent === 'Watched') {
              watchedBadgeExists = true;
              badge.classList.remove('bg-danger');
              badge.classList.add('bg-success');
            }
          });
          
          if (!watchedBadgeExists) {
            const metaDiv = itemToUpdate.querySelector('.queue-meta .d-flex:first-child');
            if (metaDiv) {
              const watchedBadge = document.createElement('span');
              watchedBadge.className = 'badge bg-success';
              watchedBadge.textContent = 'Watched';
              metaDiv.prepend(watchedBadge);
            }
          }
          
          const nextItem = findNextUnwatched();
          if (nextItem) {
            console.log('Auto-playing next unwatched item');
            // Remove active class from all items before adding it to the next item
            document.querySelectorAll('.queue-item').forEach(item => {
              item.classList.remove('active');
              item.classList.remove('bg-primary-subtle');
              item.classList.remove('border-start');
              item.classList.remove('border-2');
              item.classList.remove('border-primary-subtle');
            });
            
            // Add active class and related Bootstrap classes to the next item
            nextItem.classList.add('active');
            nextItem.classList.add('bg-primary-subtle');
            nextItem.classList.add('border-start');
            nextItem.classList.add('border-2');
            nextItem.classList.add('border-primary-subtle');
            
            // Play the next content
            playContent(nextItem);
          } else {
            console.log('No more unwatched items in queue');
          }
        } else {
          console.error('Could not find item with ID:', itemId);
        }
      }
    })
    .catch(error => console.error('Error marking as watched:', error));
  }
  
  // Mark as watched button
  document.getElementById('mark-watched-btn').addEventListener('click', function() {
    if (currentItem) {
      markAsWatched(currentItem.getAttribute('data-id'));
    }
  });
  // Mark as skipped button
  document.getElementById('mark-skipped-btn').addEventListener('click', function() {
    if (currentItem) {
      console.log('Skipping itemsss:', currentItem.getAttribute('data-id'));
      skipItem(currentItem.getAttribute('data-id'));
    }
  });

  function skipItem(itemId) {
  console.log('Toggling skip for item:', itemId);

  fetch(`/clip_queue/item/${itemId}/skip`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest'
    },
    body: JSON.stringify({})
  })
  .then(response => {
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
    return response.json();
  })
  .then(data => {
    if (!data.success) {
      console.error('Backend responded with success=false');
      return;
    }

    const item = document.querySelector(`.queue-item[data-id="${itemId}"]`);
    if (!item) {
      console.error('Could not find item element for ID:', itemId);
      return;
    }

    const skipBtn = item.querySelector('.skip-btn');
    const isSkipped = item.getAttribute('data-skipped') === 'true';

    // Toggle skipped state
    item.setAttribute('data-skipped', String(!isSkipped));
    item.classList.toggle('skipped', !isSkipped);

    if (skipBtn) {
      skipBtn.classList.toggle('btn-outline-secondary', isSkipped);
      skipBtn.classList.toggle('btn-outline-danger', !isSkipped);
      skipBtn.innerHTML = isSkipped
        ? '<i class="bi bi-fast-forward-fill"></i>'  // original skip icon
        : '<i class="bi bi-x-lg"></i>';               // skipped icon
      skipBtn.setAttribute('title', isSkipped ? 'Skip' : 'Undo skip');

      // Fully reinitialize tooltip
      const oldTooltip = bootstrap.Tooltip.getInstance(skipBtn);
      if (oldTooltip) oldTooltip.dispose();
      new bootstrap.Tooltip(skipBtn);
    }

    console.log(`${isSkipped ? 'Unskipped' : 'Skipped'} item in UI:`, itemId);
  })
  .catch(error => {
    console.error('Error toggling skip:', error);
  });
}

  // Initialize tooltips
  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
  tooltipTriggerList.map(function (tooltipTriggerEl) {
    return new bootstrap.Tooltip(tooltipTriggerEl);
  });
  
  // // WebSocket connection for live updates
  // const socket = io();
  
  // // Connect to WebSocket server
  // socket.on('connect', function() {
  //   console.log('Connected to WebSocket server');
  //   // Request current queue items
  // });
  
  // // Handle disconnection
  // socket.on('disconnect', function() {
  //   console.log('Disconnected from WebSocket server');
  // });
  
</script>
{% endblock %}
